-- Custom types
CREATE TYPE public.app_permission AS ENUM (
  "profiles.insert",
  "profiles.update",
  "profiles.delete",
  "tests.insert",
  "tests_with_profiles.all",
  "tests.delete",
  "test_quizzes.insert",
  "user_progress.select",
  "test_quizzes.delete",
  "test_quiz_correct_answers.insert",
  "user_progress.insert",
  "test_quiz_correct_answers.delete",
  "user_progress.update",
  "user_progress.delete",
  "user_points_history.select",
  "user_points_history.insert",
  "user_points_history.update",
  "user_points_history.delete",
  "blogs.insert",
  "blogs.delete",
  "blog_quizzes.insert",
  "blog_quizzes.delete",
  "blog_quiz_correct_answers.insert",
  "blog_quiz_correct_answers.delete",
  "blogs_with_profiles.all",
  "feedbacks.select",
  "feedbacks.delete"
);
create type public.app_role as enum ('admin', 'creator');

-- Create user roles table
create table public.user_roles (
  id        bigint generated by default as identity primary key,
  user_id   uuid references auth.users on delete cascade not null,
  role      app_role not null,
  unique (user_id, role)
);

alter table user_roles enable row level security;

-- Create role permissions table
create table public.role_permissions (
  id           bigint generated by default as identity primary key,
  role         app_role not null,
  permission   app_permission not null,
  unique (role, permission)
);

alter table role_permissions enable row level security;

insert into public.role_permissions (role, permission)
values
  ('admin', 'profiles.insert'),
  ('admin', 'profiles.update'),
  ('admin', 'profiles.delete'),
  ('creator', 'tests.insert'),
  ('admin', 'tests.delete'),
  ('creator', 'test_quizzes.insert'),
  ('admin', 'test_quizzes.delete'),
  ('creator', 'test_quiz_correct_answers.insert'),
  ('admin', 'test_quiz_correct_answers.delete');

-- Create the auth hook function
create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb
language plpgsql
stable
as $$
  declare
    claims jsonb;
    user_role public.app_role;
  begin
    select role into user_role from public.user_roles where user_id = (event->>'user_id')::uuid;
    claims := event->'claims';
    if user_role is not null then
      claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
    else
      claims := jsonb_set(claims, '{user_role}', 'null');
    end if;
    event := jsonb_set(event, '{claims}', claims);
    return event;
  end;
$$;
grant usage on schema public to supabase_auth_admin;

grant execute
  on function public.custom_access_token_hook
  to supabase_auth_admin;

revoke execute
  on function public.custom_access_token_hook
  from authenticated, anon, public;

grant all
  on table public.user_roles
to supabase_auth_admin;

revoke all
  on table public.user_roles
  from authenticated, anon, public;

create policy "Allow auth admin to read user roles" ON public.user_roles
as permissive for select
to supabase_auth_admin
using (true)

-- Create authorize function
create or replace function public.authorize(
  requested_permission app_permission
)
returns boolean as $$
declare
  bind_permissions int;
  user_role public.app_role;
begin
  select (auth.jwt() ->> 'user_role')::public.app_role into user_role;
  select count(*)
  into bind_permissions
  from public.role_permissions
  where role_permissions.permission = requested_permission
    and role_permissions.role = user_role;

  return bind_permissions > 0;
end;
$$ language plpgsql stable security definer set search_path = '';

-- Create profiles table
CREATE TABLE profiles (
    user_id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    full_name text NOT NULL,
    on_boarding_status text not null default 'on-boarding',
    avatar_url text,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

alter table profiles enable row level security;

create policy "Allow public read access"
    on profiles for select
    to public
    using (true);

create policy "Allow profile management"
    on profiles for update
    using (
        auth.uid() = user_id OR 
        (SELECT authorize('profiles.update'))
    );

create policy "Allow profile creation"
    on profiles for insert
    with check (
        auth.uid() = user_id OR 
        (SELECT authorize('profiles.insert'))
    );

create policy "Allow profile deletion"
    on profiles for delete
    using (
        auth.uid() = user_id OR 
        (SELECT authorize('profiles.delete'))
    );

CREATE OR REPLACE FUNCTION handle_updated_at()
returns trigger as $$
begin
    new.updated_at = now();
    return new;
end;
$$ language plpgsql;

create trigger set_updated_at
    before update on profiles
    for each row
    execute procedure handle_updated_at();

CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.raw_app_meta_data->>'provider' = 'google' THEN
    INSERT INTO public.profiles (
      user_id,
      full_name,
      avatar_url
    )
    VALUES (
      NEW.id,
      NEW.raw_user_meta_data->>'name',
      NEW.raw_user_meta_data->>'avatar_url'
    );
  ELSE
    INSERT INTO public.profiles (
      user_id,
      full_name,
      avatar_url
    )
    VALUES (
      NEW.id,
      NEW.raw_user_meta_data->>'fullName',
      CASE
        WHEN NEW.raw_user_meta_data->>'avatarUrl' IS NOT NULL THEN NEW.raw_user_meta_data->>'avatarUrl'
        ELSE NULL
      END
    );
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- Email Verification
create or replace function check_email_confirmation_token(
  user_email text
)
returns text
language plpgsql
security definer
as $$
declare
  v_token record;
begin
  select exists(
    select 1
    from auth.one_time_tokens
    where relates_to = user_email
    and token_type = 'confirmation_token'
    limit 1
  ) into v_token;
  
  if not v_token.exists then
    return 'not-exist';
  end if;
  
  select * into v_token
  from auth.one_time_tokens
  where relates_to = user_email
  and token_type = 'confirmation_token'
  order by created_at desc
  limit 1;
  
  if v_token.created_at >= now() - interval '1 hour' then
    return 'pending';
  else
    return 'expired';
  end if;
end;
$$;

CREATE OR REPLACE FUNCTION public.check_email_confirmation_cooldown(user_email text)
RETURNS integer
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
   last_sent timestamp with time zone;
   time_diff integer;
BEGIN
   SELECT users.confirmation_sent_at INTO last_sent
   FROM auth.users
   WHERE users.email = user_email;
   time_diff := COALESCE(60 - EXTRACT(EPOCH FROM (now() - last_sent))::integer, 0);
   RETURN GREATEST(LEAST(time_diff, 60), 0);
END;
$$;

-- Reset Password Verification
create or replace function check_reset_password_token(
  user_email text
)
returns text
language plpgsql
security definer
as $$
declare
  v_token record;
begin
  select exists(
    select 1
    from auth.one_time_tokens
    where relates_to = user_email
    and token_type = 'recovery_token'
    limit 1
  ) into v_token;
 
  if not v_token.exists then
    return 'not-exist';
  end if;
 
  select * into v_token
  from auth.one_time_tokens
  where relates_to = user_email
  and token_type = 'recovery_token'
  order by created_at desc
  limit 1;
 
  if v_token.created_at >= now() - interval '1 hour' then
    return 'pending';
  else
    return 'expired';
  end if;
end;
$$;

create or replace function check_reset_password_cooldown(
  user_email text
)
returns integer
language plpgsql
security definer
as $$
declare
  last_token timestamp with time zone;
  time_diff integer;
begin
  SELECT created_at INTO last_token
  FROM auth.one_time_tokens
  WHERE relates_to = user_email
  AND token_type = 'recovery_token'
  ORDER BY created_at DESC
  LIMIT 1;

  time_diff := COALESCE(60 - EXTRACT(EPOCH FROM (now() - last_token))::integer, 0);
  RETURN GREATEST(LEAST(time_diff, 60), 0);
end;
$$;

-- Get Session Amr
CREATE OR REPLACE FUNCTION public.get_session_amr()
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  _amr_method text;
BEGIN
  SELECT (auth.jwt() ->> 'amr')::jsonb->0->>'method'
  INTO _amr_method;
  RETURN _amr_method;
END;
$$;

-- Reset Password
create or replace function change_password(current_password text, new_password text)
returns text
language plpgsql
security definer
as $$
DECLARE
encpass auth.users.encrypted_password%type;
user_id uuid;
BEGIN
  user_id := auth.uid();
  SELECT encrypted_password
  FROM auth.users
  INTO encpass
  WHERE id = user_id and encrypted_password = crypt(current_password, auth.users.encrypted_password);
  IF NOT FOUND THEN
    return 'passwordIncorrect';
  END IF;
  IF current_password = new_password THEN
    return 'samePassword';
  END IF;
  BEGIN
    UPDATE auth.users 
    SET encrypted_password = crypt(new_password, gen_salt('bf')) 
    WHERE id = user_id;
    return 'resetPasswordSuccess';
  EXCEPTION
    WHEN OTHERS THEN
      return 'resetPasswordError';
  END;
END;
$$;

create or replace function public.check_user_password()
returns boolean
language plpgsql
security definer
set search_path = public
as $$
declare
    password_exists boolean;
    current_user_id uuid;
begin
    current_user_id := auth.uid();
    select 
        case 
            when encrypted_password is null or encrypted_password = '' then false 
            else true 
        end into password_exists
    from auth.users
    where id = current_user_id;
    if not found then
        return false;
    end if;
    return password_exists;
end;
$$;

-- Tests

CREATE TYPE english_level AS ENUM ('A1', 'A2', 'B1', 'B2', 'C1', 'C2');

CREATE TYPE quiz_type AS ENUM ('one_option', 'one_image', 'order_words', 'match');

CREATE TABLE tests (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  title TEXT NOT NULL CHECK (char_length(title) BETWEEN 5 AND 60),
  slug TEXT NOT NULL UNIQUE,
  description TEXT NOT NULL CHECK (char_length(description) BETWEEN 20 AND 250),
  level english_level NOT NULL DEFAULT 'A1',
  categories TEXT[] NOT NULL CHECK (array_length(categories, 1) BETWEEN 1 AND 3),
  cover_url TEXT NOT NULL,
  user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL;
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

ALTER TABLE tests ENABLE ROW LEVEL SECURITY;

CREATE TRIGGER update_tests_timestamp
BEFORE UPDATE ON tests
FOR EACH ROW EXECUTE PROCEDURE handle_updated_at();

CREATE POLICY "Allow all to view tests" 
ON tests FOR SELECT USING (
  true
);

CREATE POLICY "Allow creators to create tests" 
ON tests FOR INSERT WITH CHECK (
  (SELECT authorize('tests.insert'))
);

CREATE POLICY "Allow creators to update their own tests" 
ON tests FOR UPDATE USING (
  user_id = auth.uid()
);

CREATE POLICY "Allow creators to delete their own tests" 
ON tests FOR DELETE USING (
  (SELECT authorize('tests.delete')) OR 
  user_id = auth.uid()
);

CREATE TABLE test_quizzes (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  test_id UUID NOT NULL REFERENCES tests(id) ON DELETE CASCADE,
  question TEXT NOT NULL CHECK (char_length(question) BETWEEN 5 AND 60),
  type quiz_type NOT NULL,
  data JSONB NOT NULL,
  quiz_order INT NOT NULL CHECK (quiz_order > 0),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
ALTER TABLE test_quizzes ENABLE ROW LEVEL SECURITY;

CREATE OR REPLACE FUNCTION handle_test_quizzes_changes()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'DELETE' THEN
    UPDATE tests 
    SET updated_at = NOW() 
    WHERE id = OLD.test_id;
    RETURN OLD;
  ELSIF TG_OP = 'INSERT' THEN
    UPDATE tests 
    SET updated_at = NOW() 
    WHERE id = NEW.test_id;
    RETURN NEW;
  ELSIF TG_OP = 'UPDATE' THEN
    NEW.updated_at = NOW();
    UPDATE tests 
    SET updated_at = NOW() 
    WHERE id = NEW.test_id;
    RETURN NEW;
  END IF;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER test_quizzes_changes_trigger
  BEFORE INSERT OR UPDATE OR DELETE ON test_quizzes
  FOR EACH ROW 
  EXECUTE FUNCTION handle_test_quizzes_changes();

CREATE POLICY "Allow all to view test quizzes" 
ON test_quizzes FOR SELECT USING (
  true
);

CREATE POLICY "Allow creators to create test quizzes" 
ON test_quizzes FOR INSERT WITH CHECK (
  (SELECT authorize('test_quizzes.insert'))
);

CREATE POLICY "Allow creators to update quizzes of their own tests" 
ON test_quizzes FOR UPDATE USING (
  EXISTS (
    SELECT 1 FROM tests
    WHERE tests.id = test_quizzes.test_id
    AND tests.user_id = auth.uid()
  )
);

CREATE POLICY "Allow creators to delete quizzes of their own tests" 
ON test_quizzes FOR DELETE USING (
  (SELECT authorize('test_quizzes.delete')) OR 
  EXISTS (
    SELECT 1 FROM tests
    WHERE tests.id = test_quizzes.test_id
    AND tests.user_id = auth.uid()
  )
);


CREATE TABLE test_quiz_correct_answers (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  quiz_id UUID NOT NULL REFERENCES test_quizzes(id) ON DELETE CASCADE,
  answer_data JSONB NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(quiz_id)
);
ALTER TABLE test_quiz_correct_answers ENABLE ROW LEVEL SECURITY;

CREATE OR REPLACE FUNCTION handle_test_quiz_correct_answers_changes()
RETURNS TRIGGER AS $$
DECLARE
  parent_test_id UUID;
BEGIN
  IF TG_OP = 'DELETE' THEN
    SELECT test_id INTO parent_test_id
    FROM test_quizzes 
    WHERE id = OLD.quiz_id;
  ELSE
    SELECT test_id INTO parent_test_id
    FROM test_quizzes 
    WHERE id = NEW.quiz_id;
  END IF;
  UPDATE tests 
  SET updated_at = NOW() 
  WHERE id = parent_test_id;
  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  ELSIF TG_OP = 'INSERT' THEN
    RETURN NEW;
  ELSIF TG_OP = 'UPDATE' THEN
    NEW.updated_at = NOW();
    RETURN NEW;
  END IF;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER test_quiz_correct_answers_changes_trigger
  BEFORE INSERT OR UPDATE OR DELETE ON test_quiz_correct_answers
  FOR EACH ROW 
  EXECUTE FUNCTION handle_test_quiz_correct_answers_changes();

CREATE POLICY "Allow users to view answers of their own quizzes" 
ON test_quiz_correct_answers FOR SELECT USING (
  true
);

CREATE POLICY "Allow creators to create answers for their own quizzes" 
ON test_quiz_correct_answers FOR INSERT WITH CHECK (
  (SELECT authorize('test_quiz_correct_answers.insert'))
);

CREATE POLICY "Allow creators to update answers of their own quizzes" 
ON test_quiz_correct_answers FOR UPDATE USING (
  EXISTS (
    SELECT 1 FROM test_quizzes
    JOIN tests ON tests.id = test_quizzes.test_id
    WHERE test_quizzes.id = test_quiz_correct_answers.quiz_id
    AND tests.user_id = auth.uid()
  )
);

CREATE POLICY "Allow creators to delete answers of their own quizzes" 
ON test_quiz_correct_answers FOR DELETE USING (
  (SELECT authorize('test_quiz_correct_answers.delete')) OR 
  EXISTS (
    SELECT 1 FROM test_quizzes
    JOIN tests ON tests.id = test_quizzes.test_id
    WHERE test_quizzes.id = test_quiz_correct_answers.quiz_id
    AND tests.user_id = auth.uid()
  )
);

CREATE VIEW public.tests_with_profiles WITH (security_invoker = on) AS
SELECT t.id,
    t.title,
    t.slug,
    t.description,
    t.level,
    t.categories,
    t.cover_url,
    t.user_id,
    t.created_at,
    t.updated_at,
    p.full_name AS author_full_name,
    p.avatar_url AS author_avatar_url,
    COALESCE(json_agg(
        CASE
            WHEN tq.id IS NOT NULL THEN json_build_object(
                'id', tq.id, 
                'question', tq.question, 
                'order', tq.quiz_order, 
                'metadata', json_build_object(
                    'type', tq.type, 
                    'data', tq.data, 
                    'correctAnswer', tca.answer_data
                )
            )
            ELSE NULL::json
        END ORDER BY tq.quiz_order
    ) FILTER (WHERE tq.id IS NOT NULL), '[]'::json) AS questions
FROM tests t
    LEFT JOIN profiles p ON t.user_id = p.user_id
    LEFT JOIN test_quizzes tq ON t.id = tq.test_id
    LEFT JOIN test_quiz_correct_answers tca ON tq.id = tca.quiz_id
WHERE 
    (SELECT authorize('tests_with_profiles.all')) OR 
    t.user_id = auth.uid()
GROUP BY t.id, p.full_name, p.avatar_url;

CREATE OR REPLACE FUNCTION public.get_all_users(
  page_number INTEGER DEFAULT 0,
  page_size INTEGER DEFAULT 10,
  search_term TEXT DEFAULT NULL,
  search_levels TEXT[] DEFAULT NULL,
  search_roles TEXT[] DEFAULT NULL
) RETURNS TABLE (
  id UUID,
  email VARCHAR(255),
  role TEXT,
  full_name TEXT,
  avatar_url TEXT,
  level TEXT,
  created_at TIMESTAMP WITH TIME ZONE,
  updated_at TIMESTAMP WITH TIME ZONE
) 
SECURITY DEFINER
SET search_path = public, auth
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    u.id,
    u.email,
    COALESCE(ur.role::TEXT, 'user') AS role,
    COALESCE(p.full_name, 'Anonymous') AS full_name,
    COALESCE(p.avatar_url, NULL) AS avatar_url,
    COALESCE(up.current_level, 'A1')::TEXT AS level,
    COALESCE(p.created_at, u.created_at) AS created_at,
    COALESCE(p.updated_at, u.created_at) AS updated_at
  FROM auth.users u
  LEFT JOIN public.profiles p ON u.id = p.user_id
  LEFT JOIN public.user_roles ur ON u.id = ur.user_id
  LEFT JOIN public.user_progress up ON u.id = up.user_id
  WHERE (search_term IS NULL OR 
         u.email ILIKE '%' || search_term || '%' OR 
         p.full_name ILIKE '%' || search_term || '%')
    AND (search_levels IS NULL OR COALESCE(up.current_level, 'A1')::TEXT = ANY(search_levels))
    AND (search_roles IS NULL OR ur.role::TEXT = ANY(search_roles))
  ORDER BY u.created_at DESC
  LIMIT page_size
  OFFSET page_number * page_size;
END;
$function$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.get_users_count(
  search_term TEXT DEFAULT NULL,
  search_levels TEXT[] DEFAULT NULL,
  search_roles TEXT[] DEFAULT NULL
) RETURNS BIGINT 
SECURITY DEFINER
SET search_path = public, auth
AS $function$
DECLARE
  total_count BIGINT;
BEGIN
  SELECT COUNT(DISTINCT u.id) INTO total_count
  FROM auth.users u
  LEFT JOIN public.profiles p ON u.id = p.user_id
  LEFT JOIN public.user_roles ur ON u.id = ur.user_id
  LEFT JOIN public.user_progress up ON u.id = up.user_id
  WHERE (search_term IS NULL OR 
         u.email ILIKE '%' || search_term || '%' OR 
         p.full_name ILIKE '%' || search_term || '%')
    AND (search_levels IS NULL OR COALESCE(up.current_level, 'A1')::TEXT = ANY(search_levels))
    AND (search_roles IS NULL OR ur.role::TEXT = ANY(search_roles));
    
  RETURN total_count;
END;
$function$ LANGUAGE plpgsql;

CREATE TABLE level_requirements (
  level english_level PRIMARY KEY,
  level_order INTEGER NOT NULL UNIQUE,
  min_points INTEGER NOT NULL,
  description TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

ALTER TABLE level_requirements ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow public read access" ON level_requirements
  FOR SELECT
  USING (true);

INSERT INTO level_requirements (level, level_order, min_points, description) VALUES
  ('A1', 1, 0, 'Beginner - Can understand and use familiar everyday expressions'),
  ('A2', 2, 500, 'Elementary - Can communicate in simple and routine tasks'),
  ('B1', 3, 1500, 'Intermediate - Can deal with most situations likely to arise while traveling'),
  ('B2', 4, 3000, 'Upper Intermediate - Can interact with a degree of fluency and spontaneity'),
  ('C1', 5, 6000, 'Advanced - Can express ideas fluently and spontaneously'),
  ('C2', 6, 12000, 'Proficient - Can understand with ease virtually everything heard or read');

CREATE TYPE points_source_type AS ENUM ('blog_quiz', 'test', 'initial');

CREATE TABLE user_progress (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  total_points INTEGER NOT NULL DEFAULT 0,
  current_level english_level NOT NULL DEFAULT 'A1',
  tests_completed INTEGER NOT NULL DEFAULT 0,
  quizzes_completed INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(user_id)
);

ALTER TABLE user_progress ENABLE ROW LEVEL SECURITY;

CREATE POLICY "user_progress_select_policy" ON user_progress
  FOR SELECT
  USING (
    user_id = auth.uid() 
    OR (SELECT authorize('user_progress.select'))
  );

CREATE POLICY "user_progress_insert_policy" ON user_progress
  FOR INSERT
  WITH CHECK (
    auth.jwt() ->> 'role' = 'service_role' OR 
     (SELECT authorize('user_progress.insert'))
  );

CREATE POLICY "user_progress_update_policy" ON user_progress
  FOR UPDATE
  USING (
    user_id = auth.uid() 
    OR (SELECT authorize('user_progress.update'))
  );

CREATE POLICY "user_progress_delete_policy" ON user_progress
  FOR DELETE
  USING (
    user_id = auth.uid() 
    OR (SELECT authorize('user_progress.delete'))
  );

CREATE TRIGGER update_user_progress_timestamp
BEFORE UPDATE ON user_progress
FOR EACH ROW EXECUTE PROCEDURE handle_updated_at();

CREATE TABLE user_points_history (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  points_earned INTEGER NOT NULL CHECK (points_earned >= 0),
  source_type points_source_type NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

ALTER TABLE user_points_history ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow insert for admin or authorized users" ON user_points_history
FOR INSERT 
WITH CHECK (
  auth.jwt() ->> 'role' = 'service_role' OR 
  (SELECT authorize('user_points_history.insert'))
);

CREATE POLICY "Allow select for own records or authorized users" ON user_points_history
FOR SELECT 
USING (
  user_id = auth.uid() OR
  (SELECT authorize('user_points_history.select'))
);

CREATE POLICY "Allow update for authorized users only" ON user_points_history
FOR UPDATE 
USING (
  (SELECT authorize('user_points_history.update'))
);

CREATE POLICY "Allow delete for authorized users only" ON user_points_history
FOR DELETE 
USING (
  (SELECT authorize('user_points_history.delete'))
);

CREATE OR REPLACE FUNCTION handle_user_points()
RETURNS TRIGGER AS $$
DECLARE
  _current_level english_level;
  _next_level english_level;
  _total_points INTEGER;
BEGIN
  INSERT INTO user_progress (user_id, total_points, current_level)
  VALUES (NEW.user_id, NEW.points_earned, 'A1')
  ON CONFLICT (user_id)
  DO UPDATE SET
    total_points = user_progress.total_points + NEW.points_earned,
    updated_at = NOW()
  RETURNING total_points, current_level INTO _total_points, _current_level;
 
  SELECT level INTO _next_level
  FROM level_requirements
  WHERE min_points <= _total_points
  ORDER BY level_order DESC
  LIMIT 1;
 
  IF _next_level IS NOT NULL AND _next_level != _current_level THEN
    UPDATE user_progress
    SET current_level = _next_level,
        updated_at = NOW()
    WHERE user_id = NEW.user_id;
  END IF;
 
  IF NEW.source_type = 'test' THEN
    UPDATE user_progress
    SET tests_completed = tests_completed + 1,
        updated_at = NOW()
    WHERE user_id = NEW.user_id;
  END IF;
 
  IF NEW.source_type = 'blog_quiz' THEN
    UPDATE user_progress
    SET quizzes_completed = quizzes_completed + 1,
        updated_at = NOW()
    WHERE user_id = NEW.user_id;
  END IF;
 
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_points_added
AFTER INSERT ON user_points_history
FOR EACH ROW
EXECUTE FUNCTION handle_user_points();

CREATE TABLE blogs (
   id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  title TEXT NOT NULL CHECK (char_length(title) BETWEEN 5 AND 60),
  slug TEXT NOT NULL UNIQUE,
  description TEXT NOT NULL CHECK (char_length(description) BETWEEN 20 AND 250),
  level english_level NOT NULL DEFAULT 'A1',
  content JSONB NOT NULL,
  cover_url TEXT NOT NULL,
  user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

ALTER TABLE blogs ENABLE ROW LEVEL SECURITY;

CREATE TRIGGER update_blogs_timestamp
BEFORE UPDATE ON blogs
FOR EACH ROW EXECUTE PROCEDURE handle_updated_at();

CREATE POLICY "Allow all to view blogs" 
ON blogs FOR SELECT USING (
  true
);

CREATE POLICY "Allow creators to create blogs" 
ON blogs FOR INSERT WITH CHECK (
  (SELECT authorize('blogs.insert'))
);

CREATE POLICY "Allow creators to update their own blogs" 
ON blogs FOR UPDATE USING (
  user_id = auth.uid()
);

CREATE POLICY "Allow creators to delete their own blogs" 
ON blogs FOR DELETE USING (
  (SELECT authorize('blogs.delete')) OR 
  user_id = auth.uid()
);

CREATE TABLE blog_quizzes (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  blog_id UUID NOT NULL REFERENCES blogs(id) ON DELETE CASCADE,
  question TEXT NOT NULL CHECK (char_length(question) BETWEEN 5 AND 60),
  type quiz_type NOT NULL,
  data JSONB NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(blog_id)
);

ALTER TABLE blog_quizzes ENABLE ROW LEVEL SECURITY;

CREATE OR REPLACE FUNCTION handle_blog_quizzes_changes()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'DELETE' THEN
    UPDATE blogs 
    SET updated_at = NOW() 
    WHERE id = OLD.blog_id;
    RETURN OLD;
  ELSIF TG_OP = 'INSERT' THEN
    UPDATE blogs 
    SET updated_at = NOW() 
    WHERE id = NEW.blog_id;
    RETURN NEW;
  ELSIF TG_OP = 'UPDATE' THEN
    NEW.updated_at = NOW();
    UPDATE blogs 
    SET updated_at = NOW() 
    WHERE id = NEW.blog_id;
    RETURN NEW;
  END IF;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER blog_quizzes_changes_trigger
  BEFORE INSERT OR UPDATE OR DELETE ON blog_quizzes
  FOR EACH ROW 
  EXECUTE FUNCTION handle_blog_quizzes_changes();

CREATE POLICY "Allow all to view blog quizzes" 
ON blog_quizzes FOR SELECT USING (
  true
);

CREATE POLICY "Allow creators to create blog quizzes" 
ON blog_quizzes FOR INSERT WITH CHECK (
  (SELECT authorize('blog_quizzes.insert'))
);

CREATE POLICY "Allow creators to update quizzes of their own blogs" 
ON blog_quizzes FOR UPDATE USING (
  EXISTS (
    SELECT 1 FROM blogs
    WHERE blogs.id = blog_quizzes.blog_id
    AND blogs.user_id = auth.uid()
  )
);

CREATE POLICY "Allow creators to delete quizzes of their own blogs" 
ON blog_quizzes FOR DELETE USING (
  (SELECT authorize('blog_quizzes.delete')) OR 
  EXISTS (
    SELECT 1 FROM blogs
    WHERE blogs.id = blog_quizzes.blog_id
    AND blogs.user_id = auth.uid()
  )
);

CREATE TABLE blog_quiz_correct_answers (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  quiz_id UUID NOT NULL REFERENCES blog_quizzes(id) ON DELETE CASCADE,
  answer_data JSONB NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(quiz_id)
);

ALTER TABLE blog_quiz_correct_answers ENABLE ROW LEVEL SECURITY;

CREATE OR REPLACE FUNCTION handle_blog_quiz_correct_answers_changes()
RETURNS TRIGGER AS $$
DECLARE
  parent_blog_id UUID;
BEGIN
  IF TG_OP = 'DELETE' THEN
    SELECT blog_id INTO parent_blog_id
    FROM blog_quizzes 
    WHERE id = OLD.quiz_id;
  ELSE
    SELECT blog_id INTO parent_blog_id
    FROM blog_quizzes 
    WHERE id = NEW.quiz_id;
  END IF;
  
  UPDATE blogs 
  SET updated_at = NOW() 
  WHERE id = parent_blog_id;
  
  IF TG_OP = 'DELETE' THEN
    RETURN OLD;
  ELSIF TG_OP = 'INSERT' THEN
    RETURN NEW;
  ELSIF TG_OP = 'UPDATE' THEN
    NEW.updated_at = NOW();
    RETURN NEW;
  END IF;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER blog_quiz_correct_answers_changes_trigger
  BEFORE INSERT OR UPDATE OR DELETE ON blog_quiz_correct_answers
  FOR EACH ROW 
  EXECUTE FUNCTION handle_blog_quiz_correct_answers_changes();

CREATE POLICY "Allow users to view answers of blog quizzes" 
ON blog_quiz_correct_answers FOR SELECT USING (
  true
);

CREATE POLICY "Allow creators to create answers for their own blog quizzes" 
ON blog_quiz_correct_answers FOR INSERT WITH CHECK (
  (SELECT authorize('blog_quiz_correct_answers.insert'))
);

CREATE POLICY "Allow creators to update answers of their own blog quizzes" 
ON blog_quiz_correct_answers FOR UPDATE USING (
  EXISTS (
    SELECT 1 FROM blog_quizzes
    JOIN blogs ON blogs.id = blog_quizzes.blog_id
    WHERE blog_quizzes.id = blog_quiz_correct_answers.quiz_id
    AND blogs.user_id = auth.uid()
  )
);

CREATE POLICY "Allow creators to delete answers of their own blog quizzes" 
ON blog_quiz_correct_answers FOR DELETE USING (
  (SELECT authorize('blog_quiz_correct_answers.delete')) OR 
  EXISTS (
    SELECT 1 FROM blog_quizzes
    JOIN blogs ON blogs.id = blog_quizzes.blog_id
    WHERE blog_quizzes.id = blog_quiz_correct_answers.quiz_id
    AND blogs.user_id = auth.uid()
  )
);

CREATE VIEW public.blogs_with_profiles WITH (security_invoker = on) AS
SELECT b.id,
    b.title,
    b.slug,
    b.description,
    b.level,
    b.content,
    b.cover_url,
    b.user_id,
    b.created_at,
    b.updated_at,
    p.full_name AS author_full_name,
    p.avatar_url AS author_avatar_url,
    CASE
        WHEN bq.id IS NOT NULL THEN json_build_object(
            'id', bq.id,
            'question', bq.question,
            'metadata', json_build_object(
                'type', bq.type,
                'data', bq.data,
                'correctAnswer', bqca.answer_data
            )
        )
        ELSE NULL::json
    END AS quiz
FROM blogs b
    LEFT JOIN profiles p ON b.user_id = p.user_id
    LEFT JOIN blog_quizzes bq ON b.id = bq.blog_id
    LEFT JOIN blog_quiz_correct_answers bqca ON bq.id = bqca.quiz_id
WHERE 
    (SELECT authorize('blogs_with_profiles.all')) OR 
    b.user_id = auth.uid();

CREATE TABLE user_saved_blogs (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  blog_id UUID NOT NULL REFERENCES blogs(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(user_id, blog_id)
);

ALTER TABLE user_saved_blogs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow users to save blogs" 
ON user_saved_blogs FOR INSERT WITH CHECK (
  true
);

CREATE POLICY "Allow users to view their own saved blogs" 
ON user_saved_blogs FOR SELECT USING (
  user_id = auth.uid()
);

CREATE POLICY "Allow users to update their own saved blogs" 
ON user_saved_blogs FOR UPDATE USING (
  user_id = auth.uid()
);

CREATE POLICY "Allow users to delete their own saved blogs" 
ON user_saved_blogs FOR DELETE USING (
  user_id = auth.uid()
);

CREATE TABLE blog_quiz_user_answers (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  quiz_id UUID NOT NULL REFERENCES blog_quizzes(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id),
  user_answer JSONB NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(quiz_id, user_id) 
);

ALTER TABLE blog_quiz_user_answers ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow users to submit blog quiz answers" 
ON blog_quiz_user_answers FOR INSERT WITH CHECK (
  true
);

CREATE POLICY "Allow users to view their own blog quiz answers" 
ON blog_quiz_user_answers FOR SELECT USING (
  user_id = auth.uid()
);

CREATE POLICY "Allow users to delete their own blog quiz answers" 
ON blog_quiz_user_answers FOR DELETE USING (
  user_id = auth.uid()
);

CREATE TABLE test_user_answers (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  quiz_id UUID NOT NULL REFERENCES test_quizzes(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id),
  user_answer JSONB NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

ALTER TABLE test_user_answers ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow users to submit test answers" 
ON test_user_answers FOR INSERT WITH CHECK (
  true
);

CREATE POLICY "Allow users to view their own test answers" 
ON test_user_answers FOR SELECT USING (
  user_id = auth.uid()
);

CREATE TABLE blog_views (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  blog_id UUID NOT NULL REFERENCES blogs(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE SET NULL,
  viewed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
);

CREATE UNIQUE INDEX unique_blog_user_view 
ON blog_views(blog_id, user_id)
WHERE user_id IS NOT NULL;

ALTER TABLE blog_views ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow users to create blog views" 
ON blog_views FOR INSERT WITH CHECK (
  true
);

CREATE POLICY "Allow users to view their own blog views" 
ON blog_views FOR SELECT USING (
  true
);

CREATE TABLE blog_comments (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  blog_id UUID NOT NULL REFERENCES blogs(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id),
  content TEXT NOT NULL CHECK (char_length(content) BETWEEN 1 AND 255),
  parent_id UUID REFERENCES blog_comments(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

ALTER TABLE blog_comments ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow all to view blog comments" 
ON blog_comments FOR SELECT USING (
  true
);

CREATE POLICY "Allow authenticated users to create comments" 
ON blog_comments FOR INSERT WITH CHECK (
  true
);

CREATE POLICY "Allow users to delete their own comments" 
ON blog_comments FOR DELETE USING (
  user_id = auth.uid()
);


CREATE TABLE blog_likes (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  blog_id UUID NOT NULL REFERENCES blogs(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(blog_id, user_id)
);

ALTER TABLE blog_likes ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow all to view blog likes" 
ON blog_likes FOR SELECT USING (
  true
);

CREATE POLICY "Allow authenticated users to like blogs" 
ON blog_likes FOR INSERT WITH CHECK (
  true
);

CREATE POLICY "Allow users to unlike blogs" 
ON blog_likes FOR DELETE USING (
  user_id = auth.uid()
);

CREATE TABLE feedbacks (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  rating INTEGER NOT NULL CHECK (rating >= 1 AND rating <= 5),
  feedback TEXT CHECK (char_length(feedback) BETWEEN 1 AND 500),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

ALTER TABLE feedbacks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Allow all to view blog feedbacks" 
ON feedbacks FOR SELECT USING (
  (SELECT authorize('feedbacks.select'))
);

CREATE POLICY "Allow authenticated users to create feedbacks" 
ON feedbacks FOR INSERT WITH CHECK (
  true
);

CREATE POLICY "Allow users to delete their own feedbacks" 
ON feedbacks FOR DELETE USING (
  (SELECT authorize('feedbacks.delete'))
);

CREATE TABLE notifications (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  recipient_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  sender_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  type TEXT NOT NULL CHECK (type IN ('comment', 'reply', 'like')),
  blog_id UUID NOT NULL REFERENCES blogs(id) ON DELETE CASCADE,
  read BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_notifications_recipient ON notifications(recipient_id);
CREATE INDEX idx_notifications_read ON notifications(read);
CREATE INDEX idx_notifications_created_at ON notifications(created_at);

ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own notifications"
ON notifications FOR SELECT USING (
  recipient_id = auth.uid()
);

CREATE POLICY "System can create notifications"
ON notifications FOR INSERT WITH CHECK (
  true
);

CREATE POLICY "Users can update their own notifications"
ON notifications FOR UPDATE USING (
  recipient_id = auth.uid()
);

CREATE POLICY "Users can delete their own notifications"
ON notifications FOR DELETE USING (
  recipient_id = auth.uid()
);

CREATE OR REPLACE FUNCTION get_blog_author(blog_uuid UUID)
RETURNS UUID AS $$
BEGIN
  RETURN (SELECT user_id FROM blogs WHERE id = blog_uuid);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION get_comment_author(comment_uuid UUID)
RETURNS UUID AS $$
BEGIN
  RETURN (SELECT user_id FROM blog_comments WHERE id = comment_uuid);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION notify_comment()
RETURNS TRIGGER AS $$
DECLARE
  blog_author_id UUID;
  parent_comment_author_id UUID;
BEGIN
  blog_author_id := get_blog_author(NEW.blog_id);

  IF NEW.parent_id IS NOT NULL THEN
    parent_comment_author_id := get_comment_author(NEW.parent_id);
    
    IF parent_comment_author_id != NEW.user_id THEN
      INSERT INTO notifications (recipient_id, sender_id, type, blog_id)
      VALUES (parent_comment_author_id, NEW.user_id, 'reply', NEW.blog_id);
    END IF;
    
    IF blog_author_id != parent_comment_author_id AND blog_author_id != NEW.user_id THEN
      INSERT INTO notifications (recipient_id, sender_id, type, blog_id)
      VALUES (blog_author_id, NEW.user_id, 'comment', NEW.blog_id);
    END IF;
  ELSE
    IF blog_author_id != NEW.user_id THEN
      INSERT INTO notifications (recipient_id, sender_id, type, blog_id)
      VALUES (blog_author_id, NEW.user_id, 'comment', NEW.blog_id);
    END IF;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION notify_like()
RETURNS TRIGGER AS $$
DECLARE
  blog_author_id UUID;
BEGIN
  blog_author_id := get_blog_author(NEW.blog_id);
  IF blog_author_id != NEW.user_id THEN
    INSERT INTO notifications (recipient_id, sender_id, type, blog_id)
    VALUES (blog_author_id, NEW.user_id, 'like', NEW.blog_id);
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER trigger_comment_notification
  AFTER INSERT ON blog_comments
  FOR EACH ROW
  EXECUTE FUNCTION notify_comment();

CREATE TRIGGER trigger_like_notification
  AFTER INSERT ON blog_likes
  FOR EACH ROW
  EXECUTE FUNCTION notify_like();

CREATE OR REPLACE FUNCTION mark_notification_read(notification_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
  UPDATE notifications 
  SET read = TRUE 
  WHERE id = notification_id AND recipient_id = auth.uid();
  
  RETURN FOUND;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION mark_all_notifications_read()
RETURNS INTEGER AS $$
DECLARE
  updated_count INTEGER;
BEGIN
  UPDATE notifications 
  SET read = TRUE 
  WHERE recipient_id = auth.uid() AND read = FALSE;
  
  GET DIAGNOSTICS updated_count = ROW_COUNT;
  RETURN updated_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE FUNCTION get_unread_notification_count()
RETURNS INTEGER AS $$
BEGIN
  RETURN (
    SELECT COUNT(*)
    FROM notifications 
    WHERE recipient_id = auth.uid() AND read = FALSE
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE OR REPLACE VIEW notification_details AS
SELECT 
  n.id,
  n.recipient_id,
  n.sender_id,
  n.type,
  n.blog_id,
  n.read,
  n.created_at,
  b.title as blog_title,
  b.slug as blog_slug,
  sender.email as sender_email
FROM notifications n
LEFT JOIN blogs b ON n.blog_id = b.id
LEFT JOIN auth.users sender ON n.sender_id = sender.id;

GRANT SELECT ON notification_details TO authenticated;